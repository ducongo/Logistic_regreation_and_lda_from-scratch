# -*- coding: utf-8 -*-
"""COMP4900_ML_A1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rHuJ2P7dzU0FVPDQAQcQ9RZxar6DYPey
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style
# style.use('fivethirtyeight')
# np.random.seed(seed=42)


class LDA:
  def __init__(self, xData, yData):
    self.xData = xData
    self.yData = yData
    #self.N0 = len(data[0])
    #self.N1 = len(data[1])
    self.N0 = 0
    self.N1 = 0
    self.mean0 = []
    self.mean1 = []
    self.Py0 = 0
    self.Py1 = 0
    self.covariance_matrix = []
    ##print(self.N0, self.N1)
    self.prediction = []

    self.fit()
  


  # def log_odds(self):
  #   return np.log( (self.N1/(self.N0+self.N1)) / (self.N0/(self.N0+self.N1)) )


  # 2. Calculate Mean
  def __calculate_mean(self):
    for i in range(len(self.yData)):
      if self.yData[i]==0: 
        self.mean0 = self.xData[i] if (len(self.mean0))==0 else np.add(self.mean0, self.xData[i])
      if self.yData[i]==1:
        self.mean1 = self.xData[i] if (len(self.mean1))==0 else np.add(self.mean1, self.xData[i])
    self.mean0 = (self.mean0 / self.N0).reshape(-1,1)
    self.mean1 = (self.mean1 / self.N1).reshape(-1,1)
    return self.mean0, self.mean1 


  # # 3. Calculate scatter within and between
  # def calculate_Sw(self, data):
  #   mean = self.calculate_mean(data, data.shape[0])
  #   return np.dot((data-mean), (data-mean).T)


  def __calculate_probability(self):
    for i in range(len(self.yData)):
      if self.yData[i]==0: self.N0 += 1
      elif self.yData[i]==1: self.N1 += 1
    self.Py0 = self.N0 / (self.N0 + self.N1)
    self.Py1 = self.N1 / (self.N0 + self.N1)


  def __calculate_covariance(self):
    for i in range(len(self.yData)):
      if (self.yData[i] == 0): temp = np.subtract((self.xData[i]).reshape(-1,1), self.mean0)
      elif (self.yData[i] == 1): temp = np.subtract((self.xData[i]).reshape(-1,1), self.mean1)
      
      tempCovarianceMatrix = (np.dot(temp, temp.T)) / (np.subtract((self.N0+self.N1), 2))
      self.covariance = tempCovarianceMatrix if (i==0) else np.add(self.covariance, tempCovarianceMatrix)
    
  
  def fit(self):
    self.__calculate_probability()
    self.__calculate_mean()
    self.__calculate_covariance()


  def predict(self, data):
    coMatInverse = np.linalg.inv(self.covariance)
    for i in range(len(data)):
      deltaK0 = np.dot((data[i].reshape(-1,1)).T, np.dot(coMatInverse, self.mean0))  -  np.dot(((self.mean0).T)/2, np.dot(coMatInverse, self.mean0))  +  np.log(self.Py0)
      deltaK1 = np.dot((data[i].reshape(-1,1)).T, np.dot(coMatInverse, self.mean1))  -  np.dot(((self.mean1).T)/2, np.dot(coMatInverse, self.mean1))  +  np.log(self.Py1)
      if (deltaK0 >= deltaK1):
        self.prediction = np.array([0]) if (len(self.prediction)==0) else np.append(self.prediction, 0)
      elif (deltaK0 < deltaK1):
        self.prediction = np.array([1]) if (len(self.prediction)==0) else np.append(self.prediction, 1)
    self.prediction = self.prediction.reshape(-1,)
    return self.prediction


  def accu_eval(self, predicted, true_value):
    '''
    #print("accu-eval()")
    sumCorrect = 0
    true_value.reshape(predicted.shape)
    for i in range(len(predicted)):
      if predicted[i] == true_value[i]: sumCorrect += 1
    numerator = sumCorrect
    denominator = len(predicted)
    percentAccuracy = (sumCorrect/len(predicted))*100
    #print(" ",sumCorrect,"correct predictions out of", len(predicted), "total attempts. Accuracy =", percentAccuracy,"%")
    return numerator, denominator, percentAccuracy
    '''
    accur = np.zeros(predicted.shape)
    accur[predicted == true_value] = 1
    return (sum(accur) / accur.shape[0]) * 100
